/**
  @module gradient/2D
  @description Contains Gradient2D class
  @author Vincent Zimmer
  @version 1.0.0
  @requires [helper/getBrowserName, helper/isMobile, helper/random, GradientAbstract]
*/
import {getBrowserName, isMobile, random} from "../helper.js"
import GradientAbstract from "./abstract.js"
const PI2 = Math.PI * 2 // For efficiency

/**
  Makes 2D canvas gradient

  Based off of https://www.youtube.com/watch?v=D6EiRSRhsbQ
  Some parts generated by ChatGPT
*/
export default class Gradient2D extends GradientAbstract {
  /**
    Constructor for 2D Gradient object

    @param {HTMLElement} canvas: The canvas to add the gradient to
    @param {array} colors: The list of colors for the gradient, can be hex, rgb(a), or name
    @param {object} options: Other options for the gradient (optional)
      Values:
        - minSpeed {float} (default 0.1): Min speed for particles
        - maxSpeed {float} (default 1): Max speed for particles
        - minParticles {int} (default 10): Min number of particles
        - maxParticles {int} (default 30): Max number of particles
        - scrollListener {boolean} (default false): If true, animate gradient only while scrolling
        - fallbackGradient {HTMLElement} (default false): If input, animates html element with fallback css animation
        - resizeListenerTimeout {int} (default 500): How long to wait after window resizing has stopped before updating gradient, in ms
            (e.g. wait 500ms after scrolling to pause gradient)
        - fps {int} (default 60): The max frame rate for the canvas
        - maxParticles {int} (default 30): The max number of particles on canvas
        - resizeRedrawThreshold {int} (default 150): Only redraw canvas if window's change in dimensions is greater than this value, in px (150 recommended)
        - saturation {int} (default 8): CSS saturation filter value, needed for gradient
        - blur {int} (default 6): CSS blur filter value, since canvas is scaled down
        - brightness {int} (default 65): CSS brightness filter value

    @return {void}
  */
  constructor(canvas, colors, options = {}) {
    super()
    // Set brightness
    let brightness = ""
    options.brightness = options?.brightness || true // Auto brightness is on by default
    if (options.brightness === true && getBrowserName() === "safari") { // Auto set brightness
      // For some reason the gradient looks too bright on safari
      brightness = ` brightness(60%)`
    } else if (typeof options.brightness === "number") { // Custom brightness
      brightness = ` brightness(${options.brightness})`
    }
    // Set filters
    canvas.style.filter = `saturate(${options?.saturation || 8}) blur(${options?.blur || 6}px)` + brightness // Set canvas filters for gradient
    this.maxParticles = options?.maxParticles || 30 // The max number of particles allowed on the canvas
    this.minParticles = options?.minParticles || 10 // The min number of particles allowed on the canvas
    this._canvas = canvas // Keep canvas element
    this._context = this._canvas.getContext("2d") // Need context
    this.minSpeed = options?.minSpeed || 0.1 // Min speed of gradient particles
    this.maxSpeed = options?.maxSpeed || 1 // Max speed of gradient particles
    this._colors = colors // List of colors for gradient
    this._isPaused = true // Gradient is pause on initialization
    this.resizeListenerTimeout = options?.resizeListenerTimeout || 500 // Wait duration for resize listener timeouts (see above)
    this._fpsInterval = 1000 / (options?.fps || 60) // Max frame rate
    this._lastFrameTime = 0 // Need to keep track of the time between frames for fps
    this._resizeStartDimensions = false // Need to keep track of window dimensions to only redraw canvas if necessary
    this.resizeRedrawThreshold = options?.resizeRedrawThreshold || 150 // Only redraw canvas if window dimensions changed by +/- value
    this._updateDimensions() // Set initial canvas dimensions and particle radius
    this._initializeParticles() // Draw initial particles on canvas
    window.addEventListener("resize", this._resize.bind(this)) // Need to update canvas dimensions on window resize
  }

  /**
    Draws new particles on canvas

    @params none

    @return {void}
  */
  _initializeParticles() {
    this._particles = [] // List of particle object
    // Make particle objects
    for (let i = 1; i <= this.particleCount; i++) {
      const radius = Math.random() * (this.maxRadius - this.minRadius) + this.minRadius
      const particle = { // Make particle
        id: i, // For debugging
        x: random(radius, this._canvas.width - radius), // Keep particle on canvas
        y: random(radius, this._canvas.height - radius),
        radius: radius,
        speedX: (Math.random() * (this.maxSpeed - this.minSpeed) + this.minSpeed) / 10,
        speedY: (Math.random() * (this.maxSpeed - this.minSpeed) + this.minSpeed) / 10,
        color: this._colors.length >= this.particleCount ? this._colors[i - 1] : this._colors[random(0, this._colors.length - 1)],
        sin: Math.random() * 8.5 // To change particle size
      }
      this._particles.push(particle) // Add to list
      this._drawParticle(particle) // Draw to canvas
    }
  }

  /**
    Required Gradient class function

    @params none

    @return {string}
  */
  getType() {
    return "2d"
  }

  /**
    To be used with resize event listener, updates canvas and particle dimensions

    @params none

    @return {void}
  */
  _resize() {
    if (!this._resizeStartDimensions) { // If start dimensions are uninitialized
      this._resizeStartDimensions = {height: window.innerHeight, width: window.innerWidth} // Set them
    }
    this.pause() // Pause gradient while resizing
    clearTimeout(this._resizeTimeout) // Clear timeout, then update it
    this._resizeTimeout = setTimeout(() => {
      this._updateDimensions() // Actually update dimensions
      // If on a desktop and window resize is above redraw threshold
      // This ensures that the canvas isn't redrawn when browser menubar(s) are hidden/shown while scrolling on mobile devices
      if (!isMobile || Math.max(Math.abs(this._resizeStartDimensions.height - window.innerHeight), Math.abs(this._resizeStartDimensions.width - window.innerWidth)) > this.resizeRedrawThreshold) {
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height) // Clear entire canvas
        this._initializeParticles() // Reinitialize particles with new dimensions
      }
      this._resizeStartDimensions = false // Clear dimensions
    }, this.resizeListenerTimeout)
  }

  /**
    Updates dimensions of canvas and particles, and updates particle count based on canvas size

    @params none

    @return {void}
  */
  _updateDimensions() {
    // Set canvas to 1/4 of the window size
    this._canvas.height = window.innerHeight / 4
    this._canvas.width = window.innerWidth / 4
    this.minRadius = Math.min(this._canvas.height / 8, this._canvas.width / 8)
    this.maxRadius = Math.min(this._canvas.height / 2, this._canvas.width / 2)
    this.particleCount = Math.min(this.maxParticles, Math.max(Math.floor(window.innerHeight / 60), Math.floor(window.innerWidth / 60), this.minParticles)) // Keep count between min and max
  }

  /**
    Adds input particle object to canvas

    @params particle {object}: Particle to draw on canvas

    @return {void}
  */
  _drawParticle(particle) {
    this._context.beginPath()
    this._context.arc(particle.x, particle.y, particle.radius, 0, PI2, false) // Draw particle
    // Make gradient on particle
    const gradient = this._context.createRadialGradient(particle.x, particle.y, particle.radius * 0.01, particle.x, particle.y, particle.radius)
    gradient.addColorStop(0, particle.color)
    gradient.addColorStop(1, "rgba(0,0,0,0)")
    this._context.fillStyle = gradient
    this._context.fill()
    this._context.closePath()
  }

  /**
    Updates input particle object on the canvas

    @params particle {object}: Particle to move on canvas

    @return {void}
  */
  _updateParticle(particle) {
    // Update particle radius and speed up sin if radius is at min or max
    const radius = particle.radius + Math.sin(particle.sin),
      sin = particle.sin + (this.maxSpeed + this.minSpeed) / 1000
    if (radius >= this.maxRadius) {
      particle.sin = sin + (this.maxSpeed + this.minSpeed) / 10
      particle.radius = this.maxRadius
    } else if (radius <= this.minRadius) {
      particle.sin = sin + (this.maxSpeed + this.minSpeed) / 10
      particle.radius = this.minRadius
    } else { // No adjustment needed
      particle.radius = radius
      particle.sin = sin
    }
    // Check next x coordinate so that particle doesn't go off canvas
    if (particle.x + particle.radius + particle.speedX > this._canvas.width || particle.x - particle.radius + particle.speedX < 0) {
      particle.speedX = -particle.speedX // Change x direction
    }
    // Check next y coordinate
    if (particle.y + particle.radius + particle.speedY > this._canvas.height || particle.y - particle.radius + particle.speedY < 0) {
      particle.speedY = -particle.speedY // Change y direction
    }
    // Update particle position with speed value
    particle.x += particle.speedX
    particle.y += particle.speedY
  }

  /**
    Updates canvas by redrawing all particles

    @params currentTime {number}

    @return {void}
  */
  _animate(currentTime) {
    if (this._isPaused) {return} // Exit if gradient is paused
    // Check if enough time has passed to update the canvas (cap fps)
    if (currentTime - this._lastFrameTime >= this._fpsInterval) {
      this._context.clearRect(0, 0, this._canvas.width, this._canvas.height) // Clear canvas
      for (const particle of this._particles) { // Loop thru particles
        this._drawParticle(particle) // Redraw particle
        this._updateParticle(particle) // Update next particle values
      }
      this._lastFrameTime = currentTime // Reset the timestamp for the last frame
    }
    requestAnimationFrame(this._animate.bind(this)) // Update canvas again
  }

  /**
    Pauses gradient

    @params none

    @return {void}
  */
  pause() {
    this._isPaused = true
  }

  /**
    Plays gradient

    @params none

    @return {void}
  */
  play() {
    if (this._isPaused) { // If the gradient is paused...
      // Play it
      this._isPaused = false
      requestAnimationFrame(this._animate.bind(this))
    }
  }
}
