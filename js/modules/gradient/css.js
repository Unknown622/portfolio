/**
  @module gradient/css
  @description Contains GradientCSS class and its required functions
  @author Vincent Zimmer
  @version 1.0.0
  @requires [helper/isString, GradientAbstract]
*/
import {isString} from "../helper.js"
import GradientAbstract from "./abstract.js"

/**
  Returns a string for a gradient in css that uses hcl to calculate
  Need to include gradient type, example: element.style.background = `linear-gradient(${generateGradientBackground(colors)})`
  A cool website for this: https://www.joshwcomeau.com/gradient-generator/
  Generated by ChatGPT

  @param {array} colors: Array of color hex code strings
  @param {int} colorStops: The number of color stops for the new gradient, if unused the number of stops will be twice the amount of colors (optional)

  @return {string}
*/
export function generateHCLGradient(colors, colorStops = colors.length * 2) {
  const hclColors = colors.map(color => { // Loop thru all colors and translate to hcl
    // Check if color is valid
    if (!isString(color) || color.charAt(0) !== '#') {throw new Error("Invalid color format")}
    const [r, g, b] = color.match(/\w\w/g).map((x) => parseInt(x, 16)), // Convert hex to rgb
      [h, c, l] = rgbToHcl(r, g, b) // Convert rgb to
    return { h, c, l }
  })
  const gradientStops = [] // Array of new color stops for css gradient
  for (let i = 0; i < colorStops; i++) { // Loop thru color stops
    // Add new color stop to gradient
    const index = (i / (colorStops - 1)) * (hclColors.length - 1),
      left = Math.floor(index),
      right = Math.ceil(index),
      mix = index - left
    gradientStops.push(`hsl(${mix * (hclColors[right].h - hclColors[left].h) + hclColors[left].h}, ${mix * (hclColors[right].c - hclColors[left].c) + hclColors[left].c}%, ${mix * (hclColors[right].l - hclColors[left].l) + hclColors[left].l}%)`)
  }
  return gradientStops.join(", ")

  /**
    Converts input RGB color To HCL color

    @param {int} r: R color value
    @param {int} g: G color value
    @param {int} b: B color value

    @return {array}
  */
  function rgbToHcl(r, g, b) {
    const [h, c, l] = rgbToHsl(r, g, b),
      hRadians = (h / 360) * 2 * Math.PI
    return [h, Math.sqrt(Math.pow(c * Math.cos(hRadians), 2) + Math.pow(c * Math.sin(hRadians), 2)), l]
  }

  /**
    Converts input RGB color To HSL color

    @param {int} r: R color value
    @param {int} g: G color value
    @param {int} b: B color value

    @return {array}
  */
  function rgbToHsl(r, g, b) {
    r /= 255
    g /= 255
    b /= 255
    const max = Math.max(r, g, b)
    const min = Math.min(r, g, b)
    let h, s, l = (max + min) / 2
    if (max === min) {
      h = s = 0
    } else {
      const d = max - min
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min)
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0)
          break
        case g:
          h = (b - r) / d + 2
          break
        case b:
          h = (r - g) / d + 4
          break
      }
      h /= 6
    }
    return [h * 360, s * 100, l * 100]
  }
}

export default class GradientCSS extends GradientAbstract {
  /**
    Constructor for CSS Gradient object

    @param {HTMLElement} element: The element to add the gradient to
    @param {array} colors: The list of colors for the gradient, can only be color hex codes
    @param {object} options: Other options for the gradient (optional)
      Values:
        - size {number} (default colors.length * 150): CSS background-size
        - gradientType {string} (default linear): CSS gradient type
        - gradientOptions {string} (default ""): Gradient options (like degrees), default is none
        - useHCL {boolean} (default false): Determines to use generateHCLGradient or not
        - colorStops {int} (default colors.length * 2): The number of color stops for the new gradient, only used if useHCL is true

    @return {void}
  */
  constructor(element, colors, options = {}) {
    super()
    this._isPaused = true // Gradient is paused by default
    this._element = element
    const size = options?.size || colors.length * 150
    element.style.backgroundSize = `${size}% ${size}%`
    element.style.backgroundImage = options?.gradientType || "linear" // CSS gradient type, default is linear-gradient
      + "-gradient(" + (options?.gradientOptions ? options.gradientOptions + ", " : "")
      + (options?.useHCL ? generateHCLGradient(colors, options?.colorStops || colors.length * 2)
        : colors.join(", "))
      + ")"
    if (!element.classList.contains("paused")) {
      element.classList.add("paused")
    }
  }

  /**
    Required Gradient class function

    @params none

    @return {string}
  */
  getType() {
    return "css"
  }

  /**
    Plays gradient

    @params none

    @return {void}
  */
  play() {
    if (this._isPaused) {
      this._isPaused = false
      this._element.classList.remove("paused")
    }
  }

  /**
    Pauses gradient

    @params none

    @return {void}
  */
  pause() {
    if (!this._isPaused) {
      this._isPaused = true
      this._element.classList.add("paused")
    }
  }
}
